{"ast":null,"code":"/* global define */\n'use strict';\n\n(function (root, cx) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['isomorphic-fetch'], cx);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = cx(require('isomorphic-fetch'));\n  } else {\n    // Browser globals (root is window)\n    root.movieTrailer = cx(root.fetch);\n  }\n})(this, fetch => {\n  function handleErrors(error) {\n    const message = error && error.message ? error.message : error;\n    console.warn(`movie-trailer: ${message}`); // Throw Error( error.message )\n  }\n\n  function handleFetchErrors(response) {\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return response;\n  }\n\n  function toUrl(videoId) {\n    return encodeURI('https://www.youtube.com/watch?v=' + videoId);\n  }\n\n  function getMovieId(search, options) {\n    /* Fetch a Movie ID for querying the TMDB API */\n    const path = options && options.videoType === 'tv' ? '/3/search/tv?api_key=' : '/3/search/movie?api_key=';\n    const endpoint = 'https://api.themoviedb.org' + encodeURI(path + options.apiKey + '&query=' + search + (options.year === null ? '' : '&year=' + options.year) + (options.language === null ? '' : '&language=' + options.language));\n    const result = fetch(endpoint, {\n      method: 'GET'\n    }).then(handleFetchErrors).then(response => response.json()).then(json => {\n      if (typeof json.status_message !== 'undefined') {\n        // Error\n        throw new TypeError(json.status_message);\n      } else if (json.results.length === 0) {\n        // Retry failed search without year\n        if (options.year !== null) {\n          const {\n            year,\n            ...rest\n          } = options;\n          return getMovieId(search, rest);\n        } // Error\n\n\n        throw new Error(`No TMDB Movie found with that search query, try searching https://www.themoviedb.org/search?query=${encodeURIComponent(search)} to verify one exists`);\n      } else {\n        return json.results[0].id;\n      }\n    }).catch(error => {\n      handleErrors(error);\n      return null;\n    });\n    return result;\n  }\n\n  function getTrailer(movieId, options) {\n    const path = options && options.videoType === 'tv' ? '/3/tv/' : '/3/movie/';\n    /* Fetch single or multiple movie trailers via the TMDB API */\n\n    const endpoint = 'https://api.themoviedb.org' + encodeURI(path + movieId + '/videos?api_key=' + options.apiKey + (options.language === null ? '' : '&language=' + options.language));\n    const result = fetch(endpoint, {\n      method: 'GET'\n    }).then(handleFetchErrors).then(response => response.json()).then(json => {\n      if (typeof json.status_message !== 'undefined') {\n        // Error\n        throw new TypeError(`movie-trailer: ${json.status_message}`);\n      }\n\n      if (json.results.length === 0) {\n        // Error\n        throw new Error('No trailers found for that TMDB ID');\n      }\n\n      let {\n        results\n      } = json; // Strip all but videoId\n\n      results = results.map(result => {\n        return result.key;\n      });\n\n      if (!options.id) {\n        // Return Youtube videoId or full `Watch` URL\n        results = results.map(videoId => toUrl(videoId));\n      }\n\n      return options.multi ? [...new Set(results)] : results[0];\n    }).catch(error => {\n      handleErrors(error);\n      return null;\n    });\n    return result;\n  }\n\n  async function movieTrailer(movie, options, cb, legacy) {\n    /* Fetch movie trailers */\n    // Massage inputs\n    let config = {\n      multi: false,\n      id: false,\n      year: null,\n      language: null,\n      videoType: 'movie',\n      // Added videoType property\n      // Public Key on purpose\n      apiKey: '9d2bff12ed955c7f1f74b83187f188ae'\n    };\n\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof movie !== 'string' && !options.tmdbId) {\n      throw new Error('Expected first parameter to be a movie or TMDB ID (string)');\n    } else if (typeof options === 'function') {\n      // Second parameter is the callback\n      cb = options;\n      options = null;\n    } else if (typeof options === 'boolean' || options === 'true') {\n      // Second parameter is multi\n      config.multi = options;\n    } else if (typeof options === 'string' || typeof options === 'number') {\n      // Second parameter is year\n      config.year = options;\n      /* BACKWARDS-COMPATABILITY FOR v1 */\n\n      if (typeof legacy === 'function' && (typeof cb === 'boolean' || typeof cb === 'string' && cb === 'true')) {\n        // Third parameter is multi\n        config.multi = cb;\n        cb = legacy;\n      }\n      /* END BACKWARDS-COMPATABILITY */\n\n    } else if (typeof options === 'object') {\n      // Set options\n      config = Object.assign(config, options);\n    } // Remove invalid callback\n\n\n    if (typeof cb !== 'function') {\n      cb = null;\n    }\n\n    const movieId = config.tmdbId ? config.tmdbId : await getMovieId(movie, config).catch(error => {\n      handleErrors(error);\n      return null;\n    }); // Get the TMDB content ID\n\n    if (!movieId) {\n      // Failed\n      return null;\n    } // Get the trailers themselves\n\n\n    const result = getTrailer(movieId, config);\n\n    if (!result) {\n      // Failed\n      return null;\n    } // Call callback if supplied\n\n\n    if (cb) {\n      return result.then(response => cb(null, response)).catch(error => cb(error, null));\n    } // Return promise\n\n\n    return result;\n  } // Exposed public method\n\n\n  return movieTrailer;\n});","map":{"version":3,"sources":["/Users/prarthnaluthra/Desktop/netflix/node_modules/movie-trailer/index.js"],"names":["root","cx","define","amd","exports","module","require","movieTrailer","fetch","handleErrors","error","message","console","warn","handleFetchErrors","response","ok","Error","statusText","toUrl","videoId","encodeURI","getMovieId","search","options","path","videoType","endpoint","apiKey","year","language","result","method","then","json","status_message","TypeError","results","length","rest","encodeURIComponent","id","catch","getTrailer","movieId","map","key","multi","Set","movie","cb","legacy","config","tmdbId","Object","assign"],"mappings":"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","sourcesContent":["/* global define */\n'use strict';\n\n( function ( root, cx ) {\n\n\tif ( typeof define === 'function' && define.amd ) {\n\n\t\t// AMD\n\t\tdefine( [ 'isomorphic-fetch' ], cx )\n\n\t} else if ( typeof exports === 'object' ) {\n\n\t\t// Node, CommonJS-like\n\t\tmodule.exports = cx( require( 'isomorphic-fetch' ) )\n\n\t} else {\n\n\t\t// Browser globals (root is window)\n\t\troot.movieTrailer = cx( root.fetch )\n\n\t}\n\n} )( this, fetch => {\n\n\tfunction handleErrors( error ) {\n\n\t\tconst message = ( error && error.message ) ? error.message : error\n\t\tconsole.warn( `movie-trailer: ${message}` )\n\t\t// Throw Error( error.message )\n\n\t}\n\n\tfunction handleFetchErrors( response ) {\n\n\t\tif ( !response.ok ) {\n\n\t\t\tthrow new Error( response.statusText )\n\n\t\t}\n\n\t\treturn response\n\n\t}\n\n\tfunction toUrl( videoId ) {\n\n\t\treturn encodeURI( 'https://www.youtube.com/watch?v=' + videoId )\n\n\t}\n\n\tfunction getMovieId( search, options ) {\n\n\t\t/* Fetch a Movie ID for querying the TMDB API */\n\t\tconst path = options && options.videoType === 'tv' ? '/3/search/tv?api_key=' : '/3/search/movie?api_key='\n\n\t\tconst endpoint = 'https://api.themoviedb.org' + encodeURI( path + options.apiKey + '&query=' + search + ( ( options.year === null ) ? '' : '&year=' + options.year ) + ( ( options.language === null ) ? '' : '&language=' + options.language ) )\n\t\tconst result = fetch( endpoint, {\n\t\t\tmethod: 'GET'\n\t\t} )\n\t\t\t.then( handleFetchErrors )\n\t\t\t.then( response => response.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tif ( typeof json.status_message !== 'undefined' ) {\n\n\t\t\t\t\t// Error\n\t\t\t\t\tthrow new TypeError( json.status_message )\n\n\t\t\t\t} else if ( json.results.length === 0 ) {\n\n\t\t\t\t\t// Retry failed search without year\n\t\t\t\t\tif ( options.year !== null ) {\n\n\t\t\t\t\t\tconst { year, ...rest } = options\n\n\t\t\t\t\t\treturn getMovieId( search, rest )\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Error\n\t\t\t\t\tthrow new Error( `No TMDB Movie found with that search query, try searching https://www.themoviedb.org/search?query=${encodeURIComponent( search )} to verify one exists` )\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn json.results[0].id\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\thandleErrors( error )\n\n\t\t\t\treturn null\n\n\t\t\t} )\n\n\t\treturn result\n\n\t}\n\n\tfunction getTrailer( movieId, options ) {\n\n\t\tconst path = options && options.videoType === 'tv' ? '/3/tv/' : '/3/movie/'\n\n\t\t/* Fetch single or multiple movie trailers via the TMDB API */\n\t\tconst endpoint = 'https://api.themoviedb.org' + encodeURI( path + movieId + '/videos?api_key=' + options.apiKey + ( ( options.language === null ) ? '' : '&language=' + options.language ) )\n\t\tconst result = fetch( endpoint, {\n\t\t\tmethod: 'GET'\n\t\t} )\n\t\t\t.then( handleFetchErrors )\n\t\t\t.then( response => response.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tif ( typeof ( json.status_message ) !== 'undefined' ) {\n\n\t\t\t\t\t// Error\n\t\t\t\t\tthrow new TypeError( `movie-trailer: ${json.status_message}` )\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.results.length === 0 ) {\n\n\t\t\t\t\t// Error\n\t\t\t\t\tthrow new Error( 'No trailers found for that TMDB ID' )\n\n\t\t\t\t}\n\n\t\t\t\tlet { results } = json\n\n\t\t\t\t// Strip all but videoId\n\t\t\t\tresults = results.map( result => {\n\n\t\t\t\t\treturn result.key\n\n\t\t\t\t} )\n\n\t\t\t\tif ( !options.id ) {\n\n\t\t\t\t\t// Return Youtube videoId or full `Watch` URL\n\t\t\t\t\tresults = results.map( videoId => toUrl( videoId ) )\n\n\t\t\t\t}\n\n\t\t\t\treturn options.multi ? [ ...new Set( results ) ] : results[0]\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\thandleErrors( error )\n\n\t\t\t\treturn null\n\n\t\t\t} )\n\n\t\treturn result\n\n\t}\n\n\tasync function movieTrailer( movie, options, cb, legacy ) {\n\n\t\t/* Fetch movie trailers */\n\n\t\t// Massage inputs\n\t\tlet config = {\n\t\t\tmulti: false,\n\t\t\tid: false,\n\t\t\tyear: null,\n\t\t\tlanguage: null,\n\t\t\tvideoType: 'movie', // Added videoType property\n\n\t\t\t// Public Key on purpose\n\t\t\tapiKey: '9d2bff12ed955c7f1f74b83187f188ae'\n\t\t}\n\n\t\tif ( !options ) {\n\n\t\t\toptions = {}\n\n\t\t}\n\n\t\tif ( typeof movie !== 'string' && !options.tmdbId ) {\n\n\t\t\tthrow new Error( 'Expected first parameter to be a movie or TMDB ID (string)' )\n\n\t\t} else if ( typeof options === 'function' ) {\n\n\t\t\t// Second parameter is the callback\n\t\t\tcb = options\n\t\t\toptions = null\n\n\t\t} else if ( typeof options === 'boolean' || options === 'true' ) {\n\n\t\t\t// Second parameter is multi\n\t\t\tconfig.multi = options\n\n\t\t} else if ( typeof options === 'string' || typeof options === 'number' ) {\n\n\t\t\t// Second parameter is year\n\t\t\tconfig.year = options\n\n\t\t\t/* BACKWARDS-COMPATABILITY FOR v1 */\n\t\t\tif ( typeof legacy === 'function' && ( typeof cb === 'boolean' || ( typeof cb === 'string' && cb === 'true' ) ) ) {\n\n\t\t\t\t// Third parameter is multi\n\t\t\t\tconfig.multi = cb\n\t\t\t\tcb = legacy\n\n\t\t\t}\n\t\t\t/* END BACKWARDS-COMPATABILITY */\n\n\t\t} else if ( typeof options === 'object' ) {\n\n\t\t\t// Set options\n\t\t\tconfig = Object.assign( config, options )\n\n\t\t}\n\n\t\t// Remove invalid callback\n\t\tif ( typeof cb !== 'function' ) {\n\n\t\t\tcb = null\n\n\t\t}\n\n\t\tconst movieId = config.tmdbId ? config.tmdbId : ( await getMovieId( movie, config )\n\t\t\t.catch( error => {\n\n\t\t\t\thandleErrors( error )\n\n\t\t\t\treturn null\n\n\t\t\t} ) )\n\n\t\t// Get the TMDB content ID\n\t\tif ( !movieId ) {\n\n\t\t\t// Failed\n\t\t\treturn null\n\n\t\t}\n\n\t\t// Get the trailers themselves\n\t\tconst result = getTrailer( movieId, config )\n\n\t\tif ( !result ) {\n\n\t\t\t// Failed\n\t\t\treturn null\n\n\t\t}\n\n\t\t// Call callback if supplied\n\t\tif ( cb ) {\n\n\t\t\treturn result\n\t\t\t\t.then( response => cb( null, response ) )\n\t\t\t\t.catch( error => cb( error, null ) )\n\n\t\t}\n\n\t\t// Return promise\n\t\treturn result\n\n\t}\n\n\t// Exposed public method\n\treturn movieTrailer\n\n} )\n"]},"metadata":{},"sourceType":"script"}